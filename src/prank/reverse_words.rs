use std::{collections::HashMap, sync::LazyLock};

pub static UPSIDE_DOWN_MAP: LazyLock<HashMap<char, char>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // Uppercase letters
    map.extend([
        ('A', '‚àÄ'),
        ('B', 'êêí'),
        ('C', '∆Ü'),
        ('D', '‚óñ'),
        ('E', '∆é'),
        ('F', '‚Ñ≤'),
        ('G', '‚ÖÅ'),
        ('H', 'H'),
        ('I', 'I'),
        ('J', '≈ø'),
        ('K', ' û'),
        ('L', '‚ÖÇ'),
        ('M', 'W'),
        ('N', '·¥é'),
        ('O', 'O'),
        ('P', '‘Ä'),
        ('Q', '√í'),
        ('R', '·¥ö'),
        ('S', 'S'),
        ('T', '‚ä•'),
        ('U', '‚à©'),
        ('V', 'Œõ'),
        ('W', 'M'),
        ('X', 'X'),
        ('Y', '‚ÖÑ'),
        ('Z', 'Z'),
    ]);

    // Lowercase letters
    map.extend([
        ('a', '…ê'),
        ('b', 'q'),
        ('c', '…î'),
        ('d', 'p'),
        ('e', '«ù'),
        ('f', '…ü'),
        ('g', '∆É'),
        ('h', '…•'),
        ('i', '·¥â'),
        ('j', '…æ'),
        ('k', ' û'),
        ('l', ' É'),
        ('m', '…Ø'),
        ('n', 'u'),
        ('o', 'o'),
        ('p', 'd'),
        ('q', 'b'),
        ('r', '…π'),
        ('s', 's'),
        ('t', ' á'),
        ('u', 'n'),
        ('v', ' å'),
        ('w', ' ç'),
        ('x', 'x'),
        ('y', ' é'),
        ('z', 'z'),
    ]);

    // Numbers and punctuation
    map.extend([
        ('0', '0'),
        ('1', '∆ñ'),
        ('2', '·ÑÖ'),
        ('3', '∆ê'),
        ('4', '„Ñ£'),
        ('5', 'œõ'),
        ('6', '9'),
        ('7', '„Ñ•'),
        ('8', '8'),
        ('9', '6'),
        ('.', 'Àô'),
        (',', '\''),
        ('\'', ','),
        ('"', '‚Äû'),
        (';', 'ÿõ'),
        ('!', '¬°'),
        ('?', '¬ø'),
        ('(', ')'),
        (')', '('),
        ('[', ']'),
        (']', '['),
        ('{', '}'),
        ('}', '{'),
        ('<', '>'),
        ('>', '<'),
        ('_', '‚Äæ'),
        ('&', '‚Öã'),
        ('@', '…í'),
    ]);
    // Latin characters
    map.extend([
        ('√°', '…ê'),
        ('√†', '…ê'),
        ('√¢', '…ê'),
        ('√£', '…ê'),
        ('√§', '…ê'),
        ('√©', '«ù'),
        ('√®', '«ù'),
        ('√™', '«ù'),
        ('√´', '«ù'),
        ('√≠', 'ƒ±'),
        ('√¨', 'ƒ±'),
        ('√Æ', 'ƒ±'),
        ('√Ø', 'ƒ±'),
        ('√≥', 'o'),
        ('√≤', 'o'),
        ('√¥', 'o'),
        ('√µ', 'o'),
        ('√∂', 'o'),
        ('√∫', 'n'),
        ('√π', 'n'),
        ('√ª', 'n'),
        ('√º', 'n'),
        ('√±', 'u'),
        ('√ß', '…î'),
    ]);

    // Whitespace (preserved as-is)
    map.extend([(' ', ' '), ('\t', '\t'), ('\n', '\n'), ('\r', '\r')]);

    map
});

#[must_use]
pub fn upside_down_string(input: &str) -> String {
    input
        .chars()
        .rev()
        .map(|c| *UPSIDE_DOWN_MAP.get(&c).unwrap_or(&c))
        .collect()
}
